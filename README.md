# 智能合约练习

## 临时笔记
1. 控制权限的方式？
使用修饰器，内容是检查当前的调用者是不是owner。

2. 什么是p2p网络？
每个节点即是客户端，又是服务器，所以节点之间能够直接交互。与之对应的是cs网络，即客户端-服务端架构。

3. struct只能定义数据，和class的区别是没有函数和成员方法。

4. 变量的默认存储位置？
合约里-函数之外：storage
函数入参：memory
函数出餐：string类型是引用类型，它是storage，所以如果要返回一个字符串，需要显示指定其为memory。

~~5. ERC各个标准在应用层面实际上是一个合约，你的合约继承他们，就代表着你符合他们的标准。~~

~~6. 代币不是币，是一种数字资产，所以狗狗币，NFT，游戏道具都可以理解为代币，而以太币才是货币，还是加密货币。~~

7. solidity 0.8.0 是一个关键的版本。它解决了几个关键问题：
- 整数溢出的缺陷
- 引入 try-catch 错误处理机制
- 自定义错误类型

8. struct 是值类型，没有构造函数，所以在实例化它时，不需要使用 new 关键字，而像函数一样调用即可。

9. public、view这俩关键字可以不写，但为了更清晰表明，还是写上吧。

10. 可以直接读取合约的变量，但最好还是封装成一个方法，通过方法返回这个变量，为了封装。

11. 部署完合约之后最好验证一下合约，上传源码，以增加透明度、信任度、调试和审计。

12. public和private就不用多解释了，internal就是TypeScript的protected，solidity还多了一个 external，只能被外部调用。

13. 智能合约大小限制及优化
部署到区块链上的智能合约是以字节码的形式存在的，这个字节码受限于24k。限制原因是每个块都有gas上限。况且，合约越大，其安全性和网络性能都不佳。

优化方案：代码优化、分割合约、使用库

14. ERC20中的`transfer`和`transferFrom`的区别在于，前者只能转账人自己发起，而后者是可以b可以代替a从a地址转移到c地址，前提是a授权了b，所以它时常和approve一起使用。

15. allowlist使用mapping会更合适。

16. return通常是内部调用使用的，而外部调用，如测试用例，返回值不会传递，而是通过事件来触发，这些事件会记录到日志中。

17. 编译合约时，有时会发生编译器和你的合约指定版本不一致，需要下载docker镜像。

18. `tx.origin`和`msg.sender`都区别。前者表示整个调用的最初发起者，后者是各个阶段的发起者。

这里会涉及到一个身份验证的问题，即如果使用前者来做身份校验`tx.origin == owner`，则可能会受到恶意攻击。

19. 以太坊主要使用的哈希函数是 keccak256算法，纯，固定长度，雪崩、单向、抗碰撞。

20. `require`和`assert`对区别在于，前者用于外部参数校验，如果失败，则会返还剩余gas。后者用于内部逻辑校验，如果失败，则会消耗剩余所有的gas。消耗的目的是标记其严重性，且可以更简单的统一撤回。

21、什么是检查效果（ check-effects ）模式？

防止重入攻击，他一般包含一下几个步骤：检查条件、效果、交互。先把内部的效果更新了，再与外部交互。而不是先把余额返回给外部，再更新自己的余额。

22、运行独立验证节点最少需要32ETH,这是ETH2.0网络的硬性要求。

23、fallback 和 receive 之间有什么区别？前者是更通用的接收以太币的函数，后者则是纯粹的接收以太币时，会触发的函数，后者需要external和payable

24、上海升级后，每个区块的 gas 限制仍然是3千万。

25、gas的最大限制，防止了智能合约出现无限循环的情况。

26、`view`和`pure`的区别
前者只读，后者是纯函数

27、`transferfrom`和`safetransferfrom`的区别在于，前者用于将 token 从一个地址转移到另一个地址，但不会检查目标地址能否处理erc721代币，所以有可能永远丢失。后者则是一种更安全的形式，它会检查是否实现了ETC721Receiver接口。

28、`modifier`修饰符是一种修改函数行为的机制，可以在执行前中后，通常用于验证，条件检查和访问控制等目的。

29、transfer 和 send 之间有什么区别？为什么不应该使用它们？
都有2300gas的限制，这在早起就没有问题，但是现在的业务逻辑只会越来越复杂，最好使用call。

30、如何编写高效gas循环？
访问存储变量的成本会更高。
1. 使用本地变量：如果要访问存储变量，也先把它用一个本地变量来保存。
2. 一次性修改：跟减少回流、重绘一样，先用一个临时变量算完，最后再一次性提交。
3. 预先计算：可以把常见的情况先if出来。

31、abi.encode 和 abi.encodePacked 的区别在于是否有格式化。后者也是有风险的，比如哈希碰撞。

32、gas费用是如何得来的？由EIP-1559协议提出的BASEBASEFEE= 上一个区块的gas费+当前已消耗+当前区块限制+调整因子。
## 合约开发流程细节
1. 安装环境

2. 编写合约
3. 测试合约
- 使用默认的 `npx hardhat test` 来部署一个合约，它会随着脚本的结束而结束。使用`npx hardhat node`来启动一个节点，就可以持久化测试，直到关闭IDE。
4. 部署&验证合约
验证合约指的是把合约的源码放到区块浏览器中公开，这样有三个好处：增加透明性、增加信任度，便于调试和审计，验证教程可以看这篇[hardhat验证教程](https://hardhat.org/hardhat-runner/plugins/nomicfoundation-hardhat-verify)


## 代币合约
代币不是币，是一种数字资产，所以狗狗币，NFT，游戏道具都可以理解为代币，而以太币才是货币，还是加密货币。

ERC各个标准在应用层面实际上是一个合约，你的合约继承他们，就代表着你符合他们的标准。

合约需要符合ERC20标准，所以在合约中需要引入ERC20.sol，并且你的合约要继承他们。
```solidity
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
contract MyCoin is ERC20 {
    constructor(uint256 initialSupply) ERC20("CoinName", "CoinCode") {
        // 指定了代币发行后首先存在哪个钱包上
        _mint(msg.sender, initialSupply);
    }
    // your contract content.
}
```
## 工作量证明&权益证明
- POW：解决数学难题
- POS：矿工的代币数量和持有时间，富人愈富。

### 矿工 & 用户两条线
- 矿工：第一个通过解决数学难题的矿工拥有记账权，即可以由他来生成一个新区块。他从交易池中凑足最大的区块gas限制的交易记录，记录区块并添加到区块链中。
- 用户：发起交易，交易会放到交易池中等待被矿工添加，此时用户界面显示「待确认」状态，等到矿工把区块添加到链中，才显示「确认」。

### 竞争 & 共识机制
竞争的形成：当A矿工的新区块消息还未传播到B时，B也POW了，也会传播出去，竞争就开始了，形成了短暂的区块链分叉。
分叉的蔓延：一直分叉下去，可能会产生多条分叉链，当我发现有一条链超过6个时，就取这个最长链为准，其他的摒弃掉。

所以即使用户界面显示了「确认」，但仍然🈶可能为初步确认，而最终确认则要等到6个深度时才能确定。但为了交易速度，小额交易时就可以放松规则，大额交易则真大要等到最终确认才算确认。
https://chatgpt.com/c/356fa854-2db9-437e-ad83-7a0d959c3b74

### QA
- 比特币所说的10分钟生成一个新区块，意思是通过调整证明难度，来实现大致这样的一个间隔，而不是区块链自动生成。

